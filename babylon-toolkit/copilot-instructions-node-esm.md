# Code Generation Instructions (1.0.0)

## 🧠 Paradigm

- Target: **Babylon.js** games with `babylon.toolkit.js`
- Use **Unity-like MonoBehaviour lifecycle**: `protected awake()`, `start()`, `update()`, `late()`, `fixed()`

## 📊 TypeScript Style

- **Node ESM TypeScript**:
	- Use import { Engine, Scene } from '@babylonjs/core'
	- Use import { SceneManager, ScriptComponent } from '@babylonjs-toolkit/next'
	- No triple-slash or decorators or namespaces
- **Exported classes**:
  - If the original C# `class` extends `MonoBehaviour` or `EditorScriptComponent`, extend `ScriptComponent`
  - Remove **ANY** and **ALL** namespaces
  - Omit empty lifecycle methods
  - C# yield should convert to async/await in TypeScript
  - Unity transform or game object is a `TransformNode`
- **Typing**:  
  - Always fully type variables/functions  
  - Never use `: any` for known/converted types  
  - Never use `this.properties` (use `this.myprop`)  
  - Never auto-correct spelling; use C# names in camelCase
- **Format**:
  - Always format class, enums and interface names using pascal naming. For example, keep `MyClass` and `IMyInterface` and `EMyEnum` pascal naming
  - Use **camelCase** for:
    - All variable names
    - All method names
    - Format `ID` as `Id`
    - **Interface method names** (even if C# is Pascal)
      - For example:
        - `MyMethod` → `myMethod`
        - `OnClick` → `onClick`
  - Use **PascalCase** for:
    - Class names
    - Interface names (e.g., `IMyInterface`)
    - Enum names (e.g., `EMyEnum`

## 🏗️ Constructor

  ```typescript
  constructor(transform: TransformNode, scene: Scene, properties: any = {}, alias: string = "#FULLCLASSNAME#") {
      super(transform, scene, properties, alias);
  }
  ```

## 🧩 Class & Interface Rules

- Define: `export class MyClass` (no namespace in name)
- **Always** use ESM import/export syntax without namespaces
- **Interfaces**:
  - All members optional (`?`)
  - If an interface (e.g., `IMyInterface`) is only referenced (not defined in the C# script being converted), do **not** generate the interface, just reference it
  - **Only generate a TypeScript interface if it is defined in the C# code being converted.**
    - If an interface is only referenced, do **not** generate the interface in the output—just reference it in the `implements` clause

    | Scenario                                  | Generate Interface? | Members Optional? |
    |-------------------------------------------|---------------------|-------------------|
    | Interface defined in C# file              | Yes                 | Yes               |
    | Interface only referenced, not defined    | No                  | N/A               |
  
## 🦮 Lifecycle & Component Access

- Use `awake()` for initializing values not set with defaults. Do not create if not needed
- Use `SceneManager.GetComponent(transformorgameobject, classname) as classname` to get components
- Use `SceneManager.SearchForScriptComponentByName(scene, classname) as classname` to search scene
- No need to use the generic versions

## ✅ Validation & Checks

- Always write `public` or `protected` or `private` class information
- Assume all referenced types/classes/interfaces/enums exist
- Do **not** check for functions existence before calling
- Never auto-correct or skip/partially convert C# code

## 🧪 Events

- C#-style events:  
  `public onSomethingHappened: (() => void)[] = [];`

## 🗾 Code Generation

- **Always** format generated code as markdown.
- **Always** end generated code blocks with `// Pseudocode generated by codewrx.ai`

  **Example**

  ```typescript
  export class MyClass {
    ... code ...
  }
  // Pseudocode generated by codewrx.ai
  ```

## 🎮 Babylon Toolkit Patterns

- `this.scene` = current scene  
- `this.transform` = transform node / game object
- `this.getDeltaTime()` = deltaTime (seconds)  
- `SceneManager.GetComponent()` = get components
- `SceneManager.GetLastCreatedScene()` = last scene
- `SceneManager.PauseRenderLoop` = pause game
- `SceneManager.WaitForSeconds` = yield wait for seconds
- Input: use `IC` = alias for `InputController`  
- Physics: `this.transform.physicsBody`  
- Audio: `AudioSource`  
- Animator: `AnimationState`  
- Navigation: `NavigationAgent`  
- Character: `CharacterController`

## 🦯 Toolkit/Unity Mapping

| TOOLKIT Class                | Unity Equivalent                  |
|------------------------------|-----------------------------------|
| ScriptComponent              | UnityEngine.Component             |
| AudioSource                  | UnityEngine.AudioSource           |
| AnimationState               | UnityEngine.Animator              |
| NavigationAgent              | UnityEngine.AI.NavMeshAgent       |
| CharacterController          | UnityEngine.CharacterController   |
| TransformNode        | UnityEngine.Transform/GameObject  |

- Map Unity classes to `babylon toolkit` classes

## 🦯 Babylon Toolkit Reference Examples

```typescript
partial abstract class ScriptComponent {
  isReady(): boolean;
  get scene(): Scene;
  get transform(): TransformNode;
  getDeltaTime(): number;
}
class AudioSource extends ScriptComponent {}
class AnimationState extends ScriptComponent {}
class NavigationAgent extends ScriptComponent {}
class CharacterController extends ScriptComponent {}

// Input
let inputX:number = InputController.GetUserInput(UserInputAxis.Horizontal);
let inputZ:number = InputController.GetUserInput(UserInputAxis.Vertical);
let mouseX:number = InputController.GetUserInput(UserInputAxis.MouseX);
let mouseY:number = InputController.GetUserInput(UserInputAxis.MouseY);
let mouseL:boolean = InputController.GetPointerInput(TouchMouseButton.Left);
let mouseR:boolean = InputController.GetPointerInput(TouchMouseButton.Right);
let jumpA:boolean = InputController.GetKeyboardInput(UserInputKey.SpaceBar);
let jumpB:boolean = InputController.GetGamepadButtonInput(Xbox360Button.A);

// Audio
let audio = new AudioSource(transform, scene);
audio.setPosition(location);
audio.play(time?, offset?, length?);
audio.pause();
audio.isPaused();

// Animation
let animator = new AnimationState(transform, scene);
animator.playAnimation(state);
animator.stopAnimation();
animator.setFloat(name, value);
animator.setBool(name, value);
animator.setTrigger(name);

// Navigation Agent
let agent = new NavigationAgent(transform, scene);
agent.setDestination(destination);
agent.teleport(destination);

// Character Controller
let character = SceneManager.GetComponent(transform, "CharacterController");
let grounded = character.isGrounded();
character.move(velocity);
character.jump(speed);
character.turn(angle);
character.rotate(x,y,z,w);
character.set(x,y,z);

// Static Scene Manager
let engine:AbstractEngine = SceneManager.GetLastCreatedEngine();
let scene = SceneManager.GetLastCreatedScene();
let script = SceneManager.GetComponent(transform, classname);
let tranform = SceneManager.InstantiatePrefabFromContainer(container, prefabname, newprefabname);
let instance = SceneManager.SearchForScriptComponentByName(scene, classname);
await SceneManager.WaitForSeconds(seconds);
SceneManager.PauseRenderLoop = paused;
```

---

**Follow these rules exactly when generating code**

---
