# Instructions (1.0.0)

## 🧠 Paradigm

- Target: **Babylon.js** games with `babylon.toolkit.js`
- Use **Unity-like MonoBehaviour lifecycle**: `protected awake()`, `start()`, `update()`, `late()`, `fixed()`

## 📊 TypeScript Style

- **Node UMD TypeScript**:
	- Use import/export syntax
	- Use import 'babylonjs'
	- Use import TOOLKIT from 'babylon-toolkit'
	- No triple-slash/decorators
- **Exported classes**:
  - If the original C# `class` extends `MonoBehaviour` or `EditorScriptComponent`, extend `TOOLKIT.ScriptComponent`, otherwise extend that `class` as normal
  - Wrapped in `PROJECT` namespace
  - Omit empty lifecycle methods
  - Always use full class names with namespaces (e.g., `PROJECT.MyClass`)
- **Typing**:  
  - Always fully type variables/functions  
  - Never use `: any` for known/converted types  
  - Never use `this.properties` (use `this.myprop`)  
  - Never auto-correct spelling; use C# names in camelCase
- **Format**:
  - Always format class, enums and interface names using pascal naming. For example, keep `MyClass` and `IMyInterface` and `EMyEnum` pascal naming
  - Always use full class names with namespaces. For example, use `PROJECT.MyClass` instead of `MyClass`
  - Use **camelCase** for:
    - All variable names
    - All method names
    - **Interface method names** (even if PascalCase in C#)
      - For example:
        - `MyMethod` → `myMethod`
        - `OnClick` → `onClick`
  - Use **PascalCase** for:
    - Class names
    - Interface names (e.g., `IMyInterface`)
    - Enum names (e.g., `EMyEnum`

## 🧩 Class & Interface Rules

- Define: `export class MyClass` (no namespace in name)
- Reference other classes as `PROJECT.MyOtherClass`
- **Interfaces**:
  - All members optional (`?`)
  - Always use full namespaced references (e.g., `PROJECT.IMyInterface`)
  - If `PROJECT.IMyInterface` is only referenced (not defined in the C# script), do not generate the interface, just reference it
  - **Only generate a TypeScript interface if it is defined in the C# code being converted.**
      - If an interface is only referenced, do **not** generate the interface in the TypeScript output—just reference it in the `implements` clause
 
  ### Rationale
  
  - Marking all interface members as optional prevents TypeScript errors when classes do not implement every member.
  - Only generating interfaces that are defined in the C# code avoids duplicate or unnecessary interface definitions.

## 🏗️ Constructor

```ts
constructor(transform: BABYLON.TransformNode, scene: BABYLON.Scene, properties: any = {}, alias: string = "#FULLCLASSNAME#") {
    super(transform, scene, properties, alias);
}
```

## 🦮 Lifecycle & Component Access

- Use `awake()` for initializing values not set with defaults
- Never create `awake()` if initialization not needed
- No empty lifecycle methods
- Always use `this.getComponent(fullclassname) as fullclassname` to get components on the same transform
- Always use `TOOLKIT.SceneManager.FindScriptComponent(ownertransform, fullclassname) as fullclassname` to get components from other owner transforms
- No need to use the generic versions

## ✅ Validation & Checks

- Always write `public` or `protected` or `private` class information
- Assume all referenced types/classes/interfaces/enums exist
- Never check for function/class existence before calling
- Never auto-correct or skip/partially convert C# code

## 🧪 Events

- C#-style events:  
  `public onSomethingHappened: (() => void)[] = [];`

## 🗾 End-of-Code Marker

- End generated code with  
  `// Pseudocode generated by codewrx.ai`

## 📦 Toolkit Download Urls

- **CDN**: `https://cdn.jsdelivr.net/gh/BabylonJS/BabylonToolkit@master/Runtime/babylon.toolkit.js` and `babylon.toolkit.d.ts`

## 📦 Toolkit Node Packages

- **UMD**: `npm install babylont-toolkit`
- **ESM**: `npm install babylont-toolkit-next`

## 📦 Toolkit Starter Repos

- **UMD**: `https://github.com/MackeyK24/UMD-StarterAssets.git`
- **ESM**: `https://github.com/MackeyK24/ES6-StarterAssets.git`

## 🎮 Babylon Toolkit Patterns

- `this.scene` = current scene  
- `this.transform` = transform node  
- `this.getDeltaTime()` = deltaTime (seconds)  
- `TOOLKIT.SceneManager.GetLastCreatedScene()` = last scene  
- Input: use `TOOLKIT.InputController`  
- Physics: `this.transform.physicsBody`  
- Audio: `TOOLKIT.AudioSource`  
- Animator: `TOOLKIT.AnimationState`  
- Navigation: `TOOLKIT.NavigationAgent`  
- Character: `TOOLKIT.CharacterController`

## 🦯 Toolkit/Unity Mapping

| TOOLKIT Class                | Unity Equivalent                  |
|------------------------------|-----------------------------------|
| ScriptComponent              | UnityEngine.Component             |
| AudioSource                  | UnityEngine.AudioSource           |
| AnimationState               | UnityEngine.Animator              |
| NavigationAgent              | UnityEngine.AI.NavMeshAgent       |
| CharacterController          | UnityEngine.CharacterController   |
| BABYLON.TransformNode        | UnityEngine.Transform/GameObject  |

- Always use `TOOLKIT.` prefix for toolkit classes

---

## 🦯 Babylon Toolkit Reference Examples

```ts
namespace TOOLKIT {
	partial abstract class ScriptComponent {
		isReady(): boolean;
		get scene(): BABYLON.Scene;
		get transform(): BABYLON.TransformNode;
		getDeltaTime(): number;
		getComponent<T extends TOOLKIT.ScriptComponent>(klass: string, recursive?: boolean): T;
	}
	class AudioSource extends TOOLKIT.ScriptComponent {}
	class AnimationState extends TOOLKIT.ScriptComponent {}
	class NavigationAgent extends TOOLKIT.ScriptComponent {}
	class CharacterController extends TOOLKIT.ScriptComponent {}
}

// Input
let inputX:number = TOOLKIT.InputController.GetUserInput(TOOLKIT.UserInputAxis.Horizontal);
let inputZ:number = TOOLKIT.InputController.GetUserInput(TOOLKIT.UserInputAxis.Vertical);
let mouseX:number = TOOLKIT.InputController.GetUserInput(TOOLKIT.UserInputAxis.MouseX);
let mouseY:number = TOOLKIT.InputController.GetUserInput(TOOLKIT.UserInputAxis.MouseY);
let mouseL:boolean = TOOLKIT.InputController.GetPointerInput(TOOLKIT.TouchMouseButton.Left);
let mouseR:boolean = TOOLKIT.InputController.GetPointerInput(TOOLKIT.TouchMouseButton.Right);
let jumpA:boolean = TOOLKIT.InputController.GetKeyboardInput(TOOLKIT.UserInputKey.SpaceBar);
let jumpB:boolean = TOOLKIT.InputController.GetGamepadButtonInput(BABYLON.Xbox360Button.A);

// Audio
let audio = new TOOLKIT.AudioSource(transform, scene);
audio.setRolloffMode('linear');
audio.setPosition(location);
audio.play(time?, offset?, length?);
audio.pause();
audio.isPaused();

// Physics
this.transform.physicsBody.setLinearVelocity(velocity);
this.transform.physicsBody.setAngularVelocity(velocity);

// Animation
let animator = new TOOLKIT.AnimationState(transform, scene);
animator.playAnimation(state);
animator.stopAnimation();
animator.setFloat(name, value);
animator.setBool(name, value);
animator.setTrigger(name);

// Navigation Agent
let agent = new TOOLKIT.NavigationAgent(transform, scene);
agent.setDestination(destination);
agent.teleport(destination);

// Character Controller
let character = new TOOLKIT.CharacterController(transform, scene);
let character = this.getComponent("TOOLKIT.CharacterController") as TOOLKIT.CharacterController;
let grounded = character.isGrounded();
character.move(velocity);
character.jump(speed);
character.turn(angle);
character.rotate(x,y,z,w);
character.set(x,y,z);

// Static Scene Manager
let engine:BABYLON.AbstractEngine = TOOLKIT.SceneManager.GetLastCreatedEngine();
let scene = TOOLKIT.SceneManager.GetLastCreatedScene();
let tranform = TOOLKIT.SceneManager.InstantiatePrefabFromContainer(container, prefabname, newprefabname);
let script = TOOLKIT.SceneManager.FindScriptComponent(transform, classname);
let instance = TOOLKIT.SceneManager.SearchForScriptComponentByName(scene, classname);
```

---

**Follow these rules exactly when generating code**

---